## 1
**True**.  
If L had a finite number of strings, it would be regular.

## 2
**False**  
Let L = {0} ∪ {1} ∪ {0<sup>n</sup>1<sup>n</sup> | n ≥ 0}, which is non-regular.  
L·L = ({0} ∪ L) ∪ ({1} ∪ L) ∪ ({0<sup>n</sup>1<sup>n</sup> | n ≥ 0} ∪ L), which is non-regular.  
However, L\* = {(0+1)\*}, which is regular.

## 3
**False**.  
A \ B = A ∩ ¬B. CFLs aren't closed under intersection or complementation.

## 4
**True**.  
L(0\*) is regular, and hence decidable. So, A ≤<sub>m</sub> L(0\*) implies that A is decidable.

## 5
**False**.  
Let A be a non-regular language. Let B = ∅ and C = ∅, which are both regular.  
Observe that A ∩ B = B ∩ C = A ∩ C = ∅, which are all regular.  
However, A ∪ B ∪ C = A, which is non-regular.

## 6
**False**.  
Let A = HP and B = HP, which are both recursively enumerable.  
Observe that A ∩ B = A ∪ B = HP, which are both recursively enumerable.  
However, B = HP is not decidable.

## 7
**False**.  
Consider language L = Σ<sup>\*</sup>.  
This language can be represented by a one state DFA and NFA, but no less.

## 8
**False**.  
Let L<sub>1</sub> = ∅, which is regular, and hence context-free.  
Let L<sub>2</sub> = Σ<sup>\*</sup>, which is regular, and hence context-free.  
Observe that ¬(L<sub>1</sub> ∩ L<sub>2</sub>) = Σ<sup>\*</sup>, which is context-free.

## 9
**True**.  
A right-linear grammar generates a regular language, and so a DFA exists for it.  
We know how to convert a DFA into a left-linear grammar.

## 10
**True**.  
By Myhill-Nerode. Consider the infinite set of strings generated by 0<sup>n</sup> where n is a square.  
For any 0<sup>i</sup>, 0<sup>j</sup>, i ≠ j, where i and j are squares, observe that:  
0<sup>i<sup>2</sup></sup>1<sup>√i</sup> ∈ L, whereas  
0<sup>j<sup>2</sup></sup>1<sup>√i</sup> ∉ L.  
This implies that the set of all strings generated by 0<sup>n</sup> where n is a square is pairwise distinguishable by L, and so L has infinite index; L must be non-regular.

## 11
**True**.  
Here is a grammar that accepts L.
```
G = ({S, A, C}, {a, b, c}, R, S)  
R:
  S → AC
  A → aAb | ε
  C → bCc | ε
```

## 12
**True**.  
Let E be such an enumerator.  
Define TM R that decides L as follows.  
R = "On input x:
1. Run E until string y appears such that |y| > |x|  
2. If x was enumerated, accept; otherwise, reject."
